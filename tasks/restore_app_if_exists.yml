---
# tasks/restore_app_if_exists.yml
# Only restore settings if the app is actually installed
# Called with app_key variable

- name: "Determine app path for {{ app_backup_definitions[app_key].name }}"
  set_fact:
    app_paths_to_check:
      - "/Applications/{{ app_backup_definitions[app_key].name }}.app"
      - "{{ ansible_facts['env']['HOME'] }}/Applications/{{ app_backup_definitions[app_key].name }}.app"

- name: "Check if {{ app_backup_definitions[app_key].name }} is installed"
  stat:
    path: "{{ item }}"
  register: app_check_results
  loop: "{{ app_paths_to_check }}"

- name: "Set installation status for {{ app_backup_definitions[app_key].name }}"
  set_fact:
    app_is_installed: "{{ app_check_results.results | selectattr('stat.exists') | list | length > 0 }}"

- name: "Quit {{ app_backup_definitions[app_key].name }} before restore"
  include_tasks: quit_app.yml
  vars:
    app_name: "{{ app_backup_definitions[app_key].name }}"
  when: app_is_installed
  
- name: "Restore {{ app_backup_definitions[app_key].name }} settings"
  include_tasks: restore_app.yml
  when: app_is_installed

# ============================================================================
# POST-RESTORE: Reset container cache for sandboxed apps
# ============================================================================

- name: "Reset container for {{ app_backup_definitions[app_key].name }}"
  when: app_is_installed
  block:
    - name: "Kill any remaining processes"
      ansible.builtin.shell: |
        killall "{{ app_backup_definitions[app_key].name }}" 2>/dev/null || true
        sleep 1
      changed_when: false
      failed_when: false
    
    - name: "Clear saved application state"
      ansible.builtin.shell: |
        # Get bundle ID if it exists
        APP_PATH=$(find /Applications ~/Applications -maxdepth 1 -name "{{ app_backup_definitions[app_key].name }}.app" 2>/dev/null | head -n 1)
        if [ -n "$APP_PATH" ]; then
          BUNDLE_ID=$(defaults read "$APP_PATH/Contents/Info.plist" CFBundleIdentifier 2>/dev/null || echo "")
          if [ -n "$BUNDLE_ID" ]; then
            rm -rf ~/Library/Saved\ Application\ State/"${BUNDLE_ID}".savedState 2>/dev/null || true
          fi
        fi
      changed_when: false
      failed_when: false

    # ========================================================================
    # STRONGBOX-SPECIFIC: Force refresh of Group Container
    # ========================================================================
    - name: "Force Strongbox to re-read Group Container"
      ansible.builtin.shell: |
        # Touch the Group Container to update modification time
        touch ~/Library/Group\ Containers/group.strongbox.mac.mcguill 2>/dev/null || true
        touch ~/Library/Group\ Containers/group.strongbox.mac.mcguill/sync-manager 2>/dev/null || true
        
        # Touch all JSON files in sync-manager (database definitions)
        find ~/Library/Group\ Containers/group.strongbox.mac.mcguill/sync-manager \
          -type f -name "*.json" -exec touch {} \; 2>/dev/null || true
        
        # Force filesystem sync
        sync
        sleep 1
      changed_when: false
      failed_when: false
      when: "'strongbox' in app_key | lower"

    # ========================================================================
    # TYPEFACE-SPECIFIC: Touch Typeface container – NEED TO CHANGE THIS TO GENERIC
    # ========================================================================

    - name: "Touch container to trigger re-scan"
      ansible.builtin.shell: |
        # Touch the container directory to update modification time
        find ~/Library/Containers -maxdepth 1 -name "*typeface*" -o -name "*criminalbird*" | while read -r dir; do
          touch "$dir" 2>/dev/null || true
        done
        sync
      changed_when: false
      failed_when: false
      when: "'typeface' in app_backup_definitions[app_key].name | lower"

    # ========================================================================
    # GENERIC: Touch any Group Containers for this app
    # ========================================================================
    - name: "Touch Group Containers for {{ app_backup_definitions[app_key].name }}"
      ansible.builtin.shell: |
        # Get bundle ID
        APP_PATH=$(find /Applications ~/Applications -maxdepth 1 -name "{{ app_backup_definitions[app_key].name }}.app" 2>/dev/null | head -n 1)
        if [ -n "$APP_PATH" ]; then
          BUNDLE_ID=$(defaults read "$APP_PATH/Contents/Info.plist" CFBundleIdentifier 2>/dev/null || echo "")
          if [ -n "$BUNDLE_ID" ]; then
            # Touch matching Group Containers
            find ~/Library/Group\ Containers -maxdepth 1 -name "*${BUNDLE_ID}*" -type d | while read -r dir; do
              touch "$dir" 2>/dev/null || true
            done
          fi
        fi
        sync
      changed_when: false
      failed_when: false

    # ============================================================================
    # POST-RESTORE: Reset container cache and flush preferences
    # ============================================================================

    - name: "Post-restore refresh for {{ app_backup_definitions[app_key].name }}"
      when: app_is_installed
      block:
        - name: "Flush preference cache and clear state"
          ansible.builtin.shell: |
            # 1. Flush the preference daemon to force it to read new .plist files from disk
            killall -u $(whoami) cfprefsd 2>/dev/null || true

            # 2. Identify the Bundle ID dynamically
            APP_PATH=$(find /Applications ~/Applications -maxdepth 1 -name "{{ app_backup_definitions[app_key].name }}.app" 2>/dev/null | head -n 1)
            
            if [ -n "$APP_PATH" ]; then
              BUNDLE_ID=$(defaults read "$APP_PATH/Contents/Info.plist" CFBundleIdentifier 2>/dev/null || echo "")
              
              if [ -n "$BUNDLE_ID" ]; then
                # 3. Clear Saved Application State (prevents app from resuming with old cached data)
                rm -rf ~/Library/Saved\ Application\ State/"${BUNDLE_ID}".savedState 2>/dev/null || true
                
                # 4. Refresh standard Sandboxed Container
                if [ -d "$HOME/Library/Containers/${BUNDLE_ID}" ]; then
                  touch "$HOME/Library/Containers/${BUNDLE_ID}"
                fi
                
                # 5. Refresh Group Containers (Generic Logic)
                # This looks for folders matching the Bundle ID or the first two segments (e.g., group.com.mcguill)
                DEV_PREFIX=$(echo $BUNDLE_ID | cut -d. -f1,2)
                find ~/Library/Group\ Containers -maxdepth 1 \( -name "*${BUNDLE_ID}*" -o -name "*${DEV_PREFIX}*" \) -type d | while read -r dir; do
                  touch "$dir"
                  # Deep touch to ensure subdirectories like /Library are flagged as modified
                  find "$dir" -maxdepth 2 -exec touch {} + 2>/dev/null || true
                done
              fi
            fi
            
            # 6. Commit all disk writes
            sync
          changed_when: false
          failed_when: false

- name: "Skip {{ app_backup_definitions[app_key].name }} - not installed"
  debug:
    msg: "⏭️  Skipping {{ app_backup_definitions[app_key].name }} - app not installed"
  when: not app_is_installed