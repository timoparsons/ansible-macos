---
# ============================================================================
# File: tasks/restore_app_if_exists.yml
# Only restore settings if the app is actually installed
# Called with app_key variable
# ============================================================================

- name: "Determine app path for {{ app_backup_definitions[app_key].name }}"
  set_fact:
    app_paths_to_check:
      - "/Applications/{{ app_backup_definitions[app_key].name }}.app"
      - "{{ ansible_facts['env']['HOME'] }}/Applications/{{ app_backup_definitions[app_key].name }}.app"

- name: "Check if {{ app_backup_definitions[app_key].name }} is installed"
  stat:
    path: "{{ item }}"
  register: app_check_results
  loop: "{{ app_paths_to_check }}"

- name: "Set installation status for {{ app_backup_definitions[app_key].name }}"
  set_fact:
    app_is_installed: "{{ app_check_results.results | selectattr('stat.exists') | list | length > 0 }}"

# ============================================================================
# RESTORE OPERATIONS (only if app is installed)
# ============================================================================

- name: "Perform restore operations for {{ app_backup_definitions[app_key].name }}"
  when: app_is_installed
  block:
    # ========================================================================
    # 1. QUIT APP BEFORE RESTORE
    # ========================================================================
    
    - name: "Quit {{ app_backup_definitions[app_key].name }} before restore"
      include_tasks: quit_app.yml
      vars:
        app_name: "{{ app_backup_definitions[app_key].name }}"
    
    # ========================================================================
    # 2. RESTORE APP SETTINGS
    # ========================================================================
    
    - name: "Restore {{ app_backup_definitions[app_key].name }} settings"
      include_tasks: restore_app.yml

    # ========================================================================
    # 3. POST-RESTORE REFRESH (Generic container/cache reset)
    # ========================================================================
    
    - name: "Generic post-restore refresh for {{ app_backup_definitions[app_key].name }}"
      ansible.builtin.shell: |
        # 1. Kill any remaining app processes
        killall "{{ app_backup_definitions[app_key].name }}" 2>/dev/null || true
        sleep 1

        # 2. Flush preference daemon to force reading new .plist files
        killall -u $(whoami) cfprefsd 2>/dev/null || true

        # 3. Find app and extract Bundle ID
        APP_PATH=$(find /Applications ~/Applications -maxdepth 1 -name "{{ app_backup_definitions[app_key].name }}.app" 2>/dev/null | head -n 1)
        
        if [ -n "$APP_PATH" ]; then
          BUNDLE_ID=$(defaults read "$APP_PATH/Contents/Info.plist" CFBundleIdentifier 2>/dev/null || echo "")
          
          if [ -n "$BUNDLE_ID" ]; then
            # 3. Clear Saved Application State (prevents cached resume data)
            rm -rf ~/Library/Saved\ Application\ State/"${BUNDLE_ID}".savedState 2>/dev/null || true
            
            # 4. Deep touch standard Container (sandboxed apps)
            if [ -d "$HOME/Library/Containers/${BUNDLE_ID}" ]; then
              find "$HOME/Library/Containers/${BUNDLE_ID}" -maxdepth 2 -exec touch {} + 2>/dev/null || true
            fi
            
            # 5. Deep touch matching Group Containers
            # This handles both exact bundle ID matches and developer prefix matches
            DEV_PREFIX=$(echo $BUNDLE_ID | cut -d. -f1,2)
            find ~/Library/Group\ Containers -maxdepth 1 \
              \( -name "*${BUNDLE_ID}*" -o -name "*${DEV_PREFIX}*" \) \
              -type d | while read -r dir; do
              # Touch directory and immediate children to trigger re-scan
              find "$dir" -maxdepth 2 -exec touch {} + 2>/dev/null || true
            done
            
            # 6. Ensure all changes are written to disk
            sync
          fi
        fi
      changed_when: false
      failed_when: false

# ============================================================================
# SKIP MESSAGE (if app not installed)
# ============================================================================

- name: "Skip {{ app_backup_definitions[app_key].name }} - not installed"
  debug:
    msg: "⏭️  Skipping {{ app_backup_definitions[app_key].name }} - app not installed"
  when: not app_is_installed