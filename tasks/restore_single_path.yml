# ============================================================================
# File: tasks/restore_single_path.yml
# Restores a single path (file or directory)
# Called by restore_single_app.yml, not run directly
# ============================================================================
---
- name: "Check if backup exists: {{ path_item.dest }}"
  stat:
    path: "{{ backup_base }}/{{ path_item.dest }}"
  register: backup_check

- name: "Restore {{ path_item.dest }}"
  when: backup_check.stat.exists
  block:
    - name: "Ensure parent directory exists"
      file:
        path: "{{ (path_item.src | expanduser) | dirname }}"
        state: directory
        mode: '0755'
    
    - name: "Check if source path should be a file (has extension)"
      set_fact:
        src_is_file: "{{ (path_item.src | basename | regex_search('\\.[a-zA-Z0-9]+$')) is not none }}"
    
    # If source is a file (like .plist), find and copy the actual file from backup
    - name: "Find file in backup directory"
      find:
        paths: "{{ backup_base }}/{{ path_item.dest }}"
        file_type: file
        recurse: no
      register: backup_files
      when: src_is_file
    
    - name: "Restore file: {{ path_item.src }}"
      copy:
        src: "{{ backup_files.files[0].path }}"
        dest: "{{ path_item.src | expanduser }}"
        mode: preserve
      when: 
        - src_is_file
        - backup_files.matched > 0
    
    # If source is a directory, use synchronize
    - name: "Restore directory: {{ path_item.src }}"
      synchronize:
        src: "{{ backup_base }}/{{ path_item.dest }}/"
        dest: "{{ path_item.src | expanduser }}/"
        recursive: yes
        delete: no
      delegate_to: "{{ inventory_hostname }}"
      when: not src_is_file

- name: "Warning: Backup not found: {{ path_item.dest }}"
  debug:
    msg: "⚠️  Skipping {{ path_item.dest }} - backup does not exist"
  when: not backup_check.stat.exists