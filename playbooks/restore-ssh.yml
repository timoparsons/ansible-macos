---
# ============================================================================
# File: playbooks/restore-ssh.yml
# Restore SSH keys from compressed backup with manifest
# Supports cross-role restoration (e.g., studio ‚Üí laptop)
# Usage: ansible-playbook playbooks/restore-ssh.yml -i inventory.ini --limit laptop
# Usage: ansible-playbook playbooks/restore-ssh.yml -i inventory.ini --limit laptop -e "restore_from_machine=studio"
# ============================================================================

- name: Restore SSH Configuration from Network Volume
  hosts: all
  become: false
  
  vars:
    backup_base: "{{ macos_network_base }}/ssh"
    # Allow specifying which machine's backup to restore from
    # Default behavior:
    #   - studio/laptop: restore their own (has private keys)
    #   - editor/family: restore from studio (public keys only from their ssh_files definition)
    restore_from_machine: "{{ restore_from_machine | default('studio' if machine_type in ['editor', 'family'] else machine_type) }}"

  pre_tasks:
    - name: Check required network volumes are mounted
      include_tasks: "{{ repo_root }}/tasks/check_network_volumes.yml"
      vars:
        required_volumes: "{{ required_network_volumes }}"
      tags: ['always']
          
  tasks:
    - name: Get SSH files to restore for this machine type
      set_fact:
        files_to_restore: "{{ ssh_files | default([]) }}"
    
    - name: Determine if restoring private keys
      set_fact:
        has_private_keys: "{{ files_to_restore | selectattr('src', 'in', ['id_ed25519', 'id_rsa', 'config']) | list | length > 0 }}"

    - name: Display restore summary
      debug:
        msg: |
          üì• Restoring SSH files for {{ machine_type }} machine
          üìÇ Source: {{ backup_base }}/
          üîÑ From backup: {{ restore_from_machine }}
          üìù Files to restore: {{ files_to_restore | length }}
          {% if restore_from_machine != machine_type %}
          ‚ö†Ô∏è  Cross-role restore: {{ restore_from_machine }} ‚Üí {{ machine_type }}
          {% endif %}
          {% if has_private_keys %}
          üîë Restoring full SSH keys (private + public)
          {% else %}
          üîì Restoring public keys only (for SSH host mode)
          {% endif %}

    # ========================================================================
    # FIND LATEST BACKUP
    # ========================================================================
    
    - name: Find latest backup
      shell: |
        ls -t "{{ backup_base }}"/ssh-{{ restore_from_machine }}-*.tar.zst 2>/dev/null | head -n 1
      register: latest_backup_check
      changed_when: false
      failed_when: false

    - name: Set backup archive path
      set_fact:
        backup_archive: "{{ latest_backup_check.stdout }}"
      when: latest_backup_check.stdout != ""

    - name: Fail if no backup found
      fail:
        msg: |
          ‚ùå No SSH backup found for {{ restore_from_machine }}
          
          Expected format: {{ backup_base }}/ssh-{{ restore_from_machine }}-YYYYMMDD.tar.zst
          
          Available backups:
          {{ lookup('pipe', 'ls -1 ' + backup_base + '/*.tar.zst 2>/dev/null || echo "  None found"') }}
      when: latest_backup_check.stdout == ""

    # ========================================================================
    # RESTORE PROCESS
    # ========================================================================
    
    - name: Restore SSH keys
      when: backup_archive is defined
      block:
        - name: Ensure .ssh directory exists
          file:
            path: "{{ ansible_facts['env']['HOME'] }}/.ssh"
            state: directory
            mode: '0700'

        - name: Generate restore paths
          set_fact:
            temp_extract_dir: "/tmp/ansible-restore-ssh-{{ ansible_date_time.epoch }}"

        - name: Create temp extraction directory
          file:
            path: "{{ temp_extract_dir }}"
            state: directory
            mode: '0700'

        - name: Extract archive
          shell: |
            zstd -d -c "{{ backup_archive }}" | tar -xf - -C "{{ temp_extract_dir }}"
          environment:
            COPYFILE_DISABLE: "1"
          register: extract_result

        - name: Display extraction info
          debug:
            msg: |
              üì• Extracted backup: {{ backup_archive | basename }}
              üìÅ Temp location: {{ temp_extract_dir }}

        # ====================================================================
        # READ MANIFEST
        # ====================================================================
        
        - name: Check for manifest file
          stat:
            path: "{{ temp_extract_dir }}/manifest.json"
          register: manifest_check

        - name: Read manifest data
          slurp:
            path: "{{ temp_extract_dir }}/manifest.json"
          register: manifest_data
          when: manifest_check.stat.exists

        - name: Parse manifest
          set_fact:
            manifest: "{{ manifest_data.content | b64decode | from_json }}"
          when: manifest_check.stat.exists

        - name: Display manifest info
          debug:
            msg: |
              üìã Manifest found:
                ‚Ä¢ Version: {{ manifest.manifest_version | default('legacy') }}
                ‚Ä¢ Backed up: {{ manifest.backup_date | default('unknown') }}
                ‚Ä¢ Source machine: {{ manifest.machine_type | default('unknown') }}
                ‚Ä¢ Paths: {{ manifest.paths | length }}
                ‚Ä¢ Has private keys: {{ manifest.has_private_keys | default(false) }}
          when: manifest_check.stat.exists

        # ====================================================================
        # FILTER FILES BASED ON CURRENT MACHINE'S SSH_FILES
        # ====================================================================
        
        - name: Filter manifest to only restore files defined for this machine
          set_fact:
            files_to_restore_names: "{{ files_to_restore | map(attribute='src') | list }}"
          when: manifest_check.stat.exists

        - name: Filter manifest paths
          set_fact:
            filtered_manifest_paths: "{{ manifest.paths | selectattr('dest', 'in', files_to_restore_names) | list }}"
          when: manifest_check.stat.exists

        - name: Display filtered files
          debug:
            msg: |
              üìã Filtered for {{ machine_type }}:
                ‚Ä¢ Available in backup: {{ manifest.paths | length }}
                ‚Ä¢ Will restore: {{ filtered_manifest_paths | length }}
                ‚Ä¢ Skipping: {{ manifest.paths | length - filtered_manifest_paths | length }}
          when: manifest_check.stat.exists

        # ====================================================================
        # RESTORE USING MANIFEST
        # ====================================================================
        
        - name: Restore paths from manifest
          when: manifest_check.stat.exists
          block:
            - name: Restore each SSH file
              include_tasks: ../tasks/restore_ssh_file_from_manifest.yml
              loop: "{{ filtered_manifest_paths }}"
              loop_control:
                loop_var: path_item
                label: "{{ path_item.dest }}"
              vars:
                source_dir: "{{ temp_extract_dir }}"

        # ====================================================================
        # FALLBACK: LEGACY RESTORE
        # ====================================================================
        
        - name: Legacy restore without manifest
          when: not manifest_check.stat.exists
          block:
            - name: Warn about legacy restore
              debug:
                msg: |
                  ‚ö†Ô∏è  No manifest found - using legacy restore method
                  This backup was created before manifest support

            - name: Restore SSH files using definition
              include_tasks: ../tasks/restore_ssh_file_legacy.yml
              loop: "{{ files_to_restore }}"
              loop_control:
                loop_var: ssh_item
                label: "{{ ssh_item.dest }}"
              vars:
                source_dir: "{{ temp_extract_dir }}"

        # ====================================================================
        # SET CORRECT PERMISSIONS
        # ====================================================================
        
        - name: Ensure correct permissions on .ssh directory
          file:
            path: "{{ ansible_facts['env']['HOME'] }}/.ssh"
            state: directory
            mode: '0700'
            recurse: yes

        # ====================================================================
        # COMPLETION
        # ====================================================================
        
        - name: Display completion message
          debug:
            msg: |
              ‚úÖ SSH keys restored!
              üì¶ From: {{ backup_archive | basename }}
              üîÑ Method: {{ 'Manifest-based' if manifest_check.stat.exists else 'Legacy' }}
              üìù Restored: {{ filtered_manifest_paths | default(files_to_restore) | length }} files
              {% if restore_from_machine != machine_type %}
              üîÑ Cross-role: {{ restore_from_machine }} ‚Üí {{ machine_type }}
              {% endif %}
              üîí Permissions have been set correctly

      always:
        # ====================================================================
        # CLEANUP
        # ====================================================================
        
        - name: Cleanup temp extraction directory
          file:
            path: "{{ temp_extract_dir }}"
            state: absent
          failed_when: false