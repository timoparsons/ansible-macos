---
# ============================================================================
# File: playbooks/backup-ssh.yml
# Backup SSH keys with compression and manifest
# Creates: ssh/ssh-{role}-YYYYMMDD.tar.zst
# Only runs on studio and laptop (machines with private keys)
# Usage: ansible-playbook playbooks/backup-ssh.yml -i inventory.ini --limit studio
# ============================================================================

- name: Backup SSH Configuration to Network Volume
  hosts: all  # â† Changed from studio,laptop to all
  become: false
  
  vars:
    backup_base: "{{ macos_network_base }}/ssh"
    backup_timestamp: "{{ ansible_date_time.iso8601_basic_short'] }}"

  pre_tasks:
    - name: Check required network volumes are mounted
      include_tasks: "{{ repo_root }}/tasks/check_network_volumes.yml"
      vars:
        required_volumes: "{{ required_network_volumes }}"
      tags: ['always']
          
  tasks:
    - name: Verify network volume is mounted
      stat:
        path: "{{ macos_network_base }}"
      register: network_check
      failed_when: not network_check.stat.exists

    - name: Display backup type based on role
      debug:
        msg: |
          {% if machine_type in ['studio', 'laptop'] %}
          ğŸ”‘ Backing up FULL SSH keys (private + public) for {{ machine_type }}
          {% else %}
          ğŸ”“ Backing up PUBLIC SSH keys only for {{ machine_type }}
          {% endif %}

    # ========================================================================
    # BACKUP PROCESS
    # ========================================================================
    
    - name: Backup SSH keys with compression
      block:
        - name: Generate backup paths with unique epoch
          set_fact:
            backup_filename: "ssh-{{ machine_type }}-{{ ansible_date_time.date }}.tar.zst"
            backup_epoch: "{{ ansible_date_time.epoch }}-{{ 999999 | random }}"

        - name: Set temp paths
          set_fact:
            temp_dir: "/tmp/ansible-backup-ssh-{{ backup_epoch }}"
            temp_archive: "/tmp/{{ backup_epoch }}-{{ backup_filename }}"
            final_archive: "{{ backup_base }}/{{ backup_filename }}"

        - name: Ensure backup directory exists
          file:
            path: "{{ backup_base }}"
            state: directory
            mode: '0700'

        - name: Check if today's backup already exists
          stat:
            path: "{{ final_archive }}"
          register: existing_backup

        - name: Skip if backup exists
          debug:
            msg: "â­ï¸  Backup already exists: {{ backup_filename }}"
          when: existing_backup.stat.exists

        - name: Create SSH backup
          when: not existing_backup.stat.exists
          block:
            # ========================================================
            # 1. CHECK WHICH FILES EXIST
            # ========================================================
            
            - name: Force cleanup of staging directory
              file:
                path: "{{ temp_dir }}"
                state: absent

            - name: Create temp staging directory
              file:
                path: "{{ temp_dir }}"
                state: directory
                mode: '0700'

            - name: Check which SSH files exist
              stat:
                path: "{{ ansible_facts['env']['HOME'] }}/.ssh/{{ item.src }}"
              register: ssh_file_checks
              loop: "{{ ssh_files }}"
              loop_control:
                label: "{{ item.src }}"

            - name: Filter to existing files
              set_fact:
                existing_ssh_files: "{{ ssh_file_checks.results | selectattr('stat.exists') | map(attribute='item') | list }}"

            - name: Display files to backup
              debug:
                msg: "ğŸ“ Found {{ existing_ssh_files | length }}/{{ ssh_files | length }} SSH files"

            - name: Skip if no files exist
              meta: end_host
              when: existing_ssh_files | length == 0

            # ========================================================
            # 2. BUILD MANIFEST
            # ========================================================
            
            - name: Initialize manifest paths
              set_fact:
                manifest_paths: []

            - name: Build manifest entries
              set_fact:
                manifest_paths: "{{ manifest_paths + [manifest_entry] }}"
              loop: "{{ existing_ssh_files }}"
              vars:
                corresponding_check: "{{ ssh_file_checks.results | selectattr('item', 'equalto', item) | first }}"
                manifest_entry:
                  src: "~/.ssh/{{ item.src }}"
                  dest: "{{ item.src }}"
                  mode: "{{ item.mode }}"
                  is_file: "{{ corresponding_check.stat.isreg }}"
                  needs_sudo: false
                  is_private_key: "{{ item.src in ['id_ed25519', 'id_rsa', 'config'] }}"

            - name: Create manifest file
              copy:
                content: |
                  {
                    "backup_type": "ssh",
                    "backup_date": "{{ ansible_date_time.date }}",
                    "backup_timestamp": "{{ ansible_date_time.iso8601 }}",
                    "machine_type": "{{ machine_type }}",
                    "manifest_version": "1.0",
                    "has_private_keys": true,
                    "paths": {{ manifest_paths | to_json }}
                  }
                dest: "{{ temp_dir }}/manifest.json"

            # ========================================================
            # 3. STAGE FILES
            # ========================================================
            
            - name: Copy SSH files to staging directory
              shell: |
                set -e
                SRC="{{ ansible_facts['env']['HOME'] }}/.ssh/{{ item.src }}"
                DEST="{{ temp_dir }}/{{ item.dest }}"
                
                mkdir -p "$(dirname "$DEST")"
                cp -p "$SRC" "$DEST"
              loop: "{{ existing_ssh_files }}"
              loop_control:
                label: "{{ item.src }}"
              no_log: true

            # ========================================================
            # 4. COMPRESS
            # ========================================================
            
            - name: Check if zstd is installed
              command: which zstd
              register: zstd_check
              changed_when: false
              failed_when: false

            - name: Install zstd if missing
              community.general.homebrew:
                name: zstd
                state: present
              when: zstd_check.rc != 0

            - name: Get size before compression
              shell: du -sk "{{ temp_dir }}" | cut -f1
              register: original_size
              changed_when: false

            - name: Create compressed archive
              shell: |
                cd "{{ temp_dir }}"
                COPYFILE_DISABLE=1 gtar \
                  --no-xattrs \
                  --no-acls \
                  -cf - . | \
                  zstd -T0 -10 -q -o "{{ temp_archive }}"
              environment:
                COPYFILE_DISABLE: "1"

            - name: Get compressed size
              stat:
                path: "{{ temp_archive }}"
              register: compressed_stats

            - name: Calculate compression ratio
              set_fact:
                compression_ratio: "{{ ((1 - (compressed_stats.stat.size / (original_size.stdout | int * 1024))) * 100) | round(1) }}"
              when: (original_size.stdout | int) > 0

            # ========================================================
            # 5. MOVE TO NETWORK
            # ========================================================
            
            - name: Move archive to network location
              command: mv "{{ temp_archive }}" "{{ final_archive }}"
              register: move_result
              changed_when: move_result.rc == 0

            - name: Set secure permissions on backup
              file:
                path: "{{ final_archive }}"
                mode: '0600'

            # ========================================================
            # 6. SUMMARY
            # ========================================================
            
            - name: Display backup summary
              debug:
                msg: |
                  âœ… SSH backup created: {{ backup_filename }}
                  ğŸ“¦ Original: {{ (original_size.stdout | int / 1024) | round(2) }} MB
                  ğŸ’¾ Compressed: {{ (compressed_stats.stat.size / 1024 / 1024) | round(2) }} MB
                  ğŸ“‰ Saved: {{ compression_ratio | default('N/A') }}%
                  ğŸ“ Location: {{ final_archive }}
                  ğŸ“‹ Manifest: {{ manifest_paths | length }} paths
                  ğŸ” Contains private keys

          always:
            # ========================================================
            # 7. CLEANUP
            # ========================================================
            
            - name: Cleanup temp staging directory
              file:
                path: "{{ temp_dir }}"
                state: absent
              failed_when: false

            - name: Cleanup temp archive if move failed
              file:
                path: "{{ temp_archive }}"
                state: absent
              failed_when: false
              when: move_result is defined and move_result.rc != 0