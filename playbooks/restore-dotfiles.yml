---
# ============================================================================
# File: playbooks/restore-dotfiles.yml
# Restore dotfiles from compressed backup with manifest
# Supports cross-role restoration (e.g., studio ‚Üí laptop)
# Usage: ansible-playbook playbooks/restore-dotfiles.yml -i inventory.ini --limit laptop
# Usage: ansible-playbook playbooks/restore-dotfiles.yml -i inventory.ini --limit laptop -e "restore_from_machine=studio"
# ============================================================================

- name: Restore Dotfiles from Network Volume
  hosts: all
  become: false
  
  vars:
    backup_base: "{{ macos_network_base }}/dotfiles"
    # Allow specifying which machine's backup to restore from
    # Defaults to current machine type
    restore_from_machine: "{{ restore_from_machine | default(machine_type) }}"

  pre_tasks:
    - name: Check required network volumes are mounted
      include_tasks: "{{ repo_root }}/tasks/check_network_volumes.yml"
      vars:
        required_volumes: "{{ required_network_volumes }}"
      tags: ['always']
          
  tasks:
    - name: Display restore summary
      debug:
        msg: |
          üì• Restoring dotfiles for {{ machine_type }} machine
          üìÇ Source: {{ backup_base }}/
          üîÑ From backup: {{ restore_from_machine }}
          {% if restore_from_machine != machine_type %}
          ‚ö†Ô∏è  Cross-role restore: {{ restore_from_machine }} ‚Üí {{ machine_type }}
          {% endif %}

    # ========================================================================
    # FIND LATEST BACKUP
    # ========================================================================
    
    - name: Find latest backup
      shell: |
        ls -t "{{ backup_base }}"/dotfiles-{{ restore_from_machine }}-*.tar.zst 2>/dev/null | head -n 1
      register: latest_backup_check
      changed_when: false
      failed_when: false

    - name: Set backup archive path
      set_fact:
        backup_archive: "{{ latest_backup_check.stdout }}"
      when: latest_backup_check.stdout != ""

    - name: Fail if no backup found
      fail:
        msg: |
          ‚ùå No dotfiles backup found for {{ restore_from_machine }}
          
          Expected format: {{ backup_base }}/dotfiles-{{ restore_from_machine }}-YYYYMMDD.tar.zst
          
          Available backups:
          {{ lookup('pipe', 'ls -1 ' + backup_base + '/*.tar.zst 2>/dev/null || echo "  None found"') }}
      when: latest_backup_check.stdout == ""

    # ========================================================================
    # RESTORE PROCESS
    # ========================================================================
    
    - name: Restore dotfiles
      when: backup_archive is defined
      block:
        - name: Generate restore paths
          set_fact:
            temp_extract_dir: "/tmp/ansible-restore-dotfiles-{{ ansible_date_time.epoch }}"

        - name: Create temp extraction directory
          file:
            path: "{{ temp_extract_dir }}"
            state: directory
            mode: '0755'

        - name: Extract archive
          shell: |
            zstd -d -c "{{ backup_archive }}" | tar -xf - -C "{{ temp_extract_dir }}"
          environment:
            COPYFILE_DISABLE: "1"
          register: extract_result

        - name: Display extraction info
          debug:
            msg: |
              üì• Extracted backup: {{ backup_archive | basename }}
              üìÅ Temp location: {{ temp_extract_dir }}

        # ====================================================================
        # READ MANIFEST
        # ====================================================================
        
        - name: Check for manifest file
          stat:
            path: "{{ temp_extract_dir }}/manifest.json"
          register: manifest_check

        - name: Read manifest data
          slurp:
            path: "{{ temp_extract_dir }}/manifest.json"
          register: manifest_data
          when: manifest_check.stat.exists

        - name: Parse manifest
          set_fact:
            manifest: "{{ manifest_data.content | b64decode | from_json }}"
          when: manifest_check.stat.exists

        - name: Display manifest info
          debug:
            msg: |
              üìã Manifest found:
                ‚Ä¢ Version: {{ manifest.manifest_version | default('legacy') }}
                ‚Ä¢ Backed up: {{ manifest.backup_date | default('unknown') }}
                ‚Ä¢ Source machine: {{ manifest.machine_type | default('unknown') }}
                ‚Ä¢ Paths: {{ manifest.paths | length }}
          when: manifest_check.stat.exists

        # ====================================================================
        # RESTORE USING MANIFEST
        # ====================================================================
        
        - name: Restore paths from manifest
          when: manifest_check.stat.exists
          block:
            - name: Restore each dotfile
              include_tasks: ../tasks/restore_dotfile_from_manifest.yml
              loop: "{{ manifest.paths }}"
              loop_control:
                loop_var: path_item
                label: "{{ path_item.src }}"
              vars:
                source_dir: "{{ temp_extract_dir }}"

        # ====================================================================
        # FALLBACK: LEGACY RESTORE
        # ====================================================================
        
        - name: Legacy restore without manifest
          when: not manifest_check.stat.exists
          block:
            - name: Warn about legacy restore
              debug:
                msg: |
                  ‚ö†Ô∏è  No manifest found - using legacy restore method
                  This backup was created before manifest support

            - name: Get dotfiles list
              set_fact:
                dotfiles_list: "{{ lookup('vars', restore_from_machine + '_dotfiles_files', default=[]) }}"

            - name: Restore dotfiles using definition
              include_tasks: ../tasks/restore_dotfile_legacy.yml
              loop: "{{ dotfiles_list }}"
              loop_control:
                loop_var: dotfile_item
                label: "{{ dotfile_item.dest }}"
              vars:
                source_dir: "{{ temp_extract_dir }}"

        # ====================================================================
        # COMPLETION
        # ====================================================================
        
        - name: Display completion message
          debug:
            msg: |
              ‚úÖ Dotfiles restored!
              üì¶ From: {{ backup_archive | basename }}
              üîÑ Method: {{ 'Manifest-based' if manifest_check.stat.exists else 'Legacy' }}
              {% if restore_from_machine != machine_type %}
              üîÑ Cross-role: {{ restore_from_machine }} ‚Üí {{ machine_type }}
              {% endif %}

      always:
        # ====================================================================
        # CLEANUP
        # ====================================================================
        
        - name: Cleanup temp extraction directory
          file:
            path: "{{ temp_extract_dir }}"
            state: absent
          failed_when: false